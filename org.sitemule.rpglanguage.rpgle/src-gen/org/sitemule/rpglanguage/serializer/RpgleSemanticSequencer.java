/*
 * generated by Xtext 2.19.0
 */
package org.sitemule.rpglanguage.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.sitemule.rpglanguage.rpgle.And;
import org.sitemule.rpglanguage.rpgle.Assignment;
import org.sitemule.rpglanguage.rpgle.Chain;
import org.sitemule.rpglanguage.rpgle.Close;
import org.sitemule.rpglanguage.rpgle.Compare;
import org.sitemule.rpglanguage.rpgle.CompareRight;
import org.sitemule.rpglanguage.rpgle.Ctrlopt;
import org.sitemule.rpglanguage.rpgle.Datatype;
import org.sitemule.rpglanguage.rpgle.Dclf;
import org.sitemule.rpglanguage.rpgle.Dclproc;
import org.sitemule.rpglanguage.rpgle.Dcls;
import org.sitemule.rpglanguage.rpgle.Directive;
import org.sitemule.rpglanguage.rpgle.Do;
import org.sitemule.rpglanguage.rpgle.Dou;
import org.sitemule.rpglanguage.rpgle.Dow;
import org.sitemule.rpglanguage.rpgle.Else;
import org.sitemule.rpglanguage.rpgle.Eof;
import org.sitemule.rpglanguage.rpgle.Expression;
import org.sitemule.rpglanguage.rpgle.Exsr;
import org.sitemule.rpglanguage.rpgle.For;
import org.sitemule.rpglanguage.rpgle.Language;
import org.sitemule.rpglanguage.rpgle.Open;
import org.sitemule.rpglanguage.rpgle.Opt;
import org.sitemule.rpglanguage.rpgle.Options;
import org.sitemule.rpglanguage.rpgle.Or;
import org.sitemule.rpglanguage.rpgle.Other;
import org.sitemule.rpglanguage.rpgle.Parm1;
import org.sitemule.rpglanguage.rpgle.Read;
import org.sitemule.rpglanguage.rpgle.Reade;
import org.sitemule.rpglanguage.rpgle.Return;
import org.sitemule.rpglanguage.rpgle.Rnf;
import org.sitemule.rpglanguage.rpgle.RpglePackage;
import org.sitemule.rpglanguage.rpgle.Selectblock;
import org.sitemule.rpglanguage.rpgle.Setgt;
import org.sitemule.rpglanguage.rpgle.Setll;
import org.sitemule.rpglanguage.rpgle.Subrutine;
import org.sitemule.rpglanguage.services.RpgleGrammarAccess;

@SuppressWarnings("all")
public class RpgleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RpgleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RpglePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RpglePackage.AND:
				sequence_AndExpr(context, (And) semanticObject); 
				return; 
			case RpglePackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case RpglePackage.BOOLEAN:
				if (rule == grammarAccess.getBooleanRule()) {
					sequence_Boolean(context, (org.sitemule.rpglanguage.rpgle.Boolean) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElseifRule()) {
					sequence_Boolean_Elseif(context, (org.sitemule.rpglanguage.rpgle.Boolean) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfRule()) {
					sequence_Boolean_If(context, (org.sitemule.rpglanguage.rpgle.Boolean) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCodeRule()
						|| rule == grammarAccess.getStmtRule()
						|| rule == grammarAccess.getIfblockRule()) {
					sequence_Boolean_If_Ifblock(context, (org.sitemule.rpglanguage.rpgle.Boolean) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWhenRule()) {
					sequence_Boolean_When(context, (org.sitemule.rpglanguage.rpgle.Boolean) semanticObject); 
					return; 
				}
				else break;
			case RpglePackage.CHAIN:
				sequence_Chain(context, (Chain) semanticObject); 
				return; 
			case RpglePackage.CLOSE:
				sequence_Close(context, (Close) semanticObject); 
				return; 
			case RpglePackage.COMPARE:
				sequence_Compare(context, (Compare) semanticObject); 
				return; 
			case RpglePackage.COMPARE_RIGHT:
				sequence_CompareRight(context, (CompareRight) semanticObject); 
				return; 
			case RpglePackage.CTRLOPT:
				sequence_Ctrlopt(context, (Ctrlopt) semanticObject); 
				return; 
			case RpglePackage.DATATYPE:
				sequence_Datatype(context, (Datatype) semanticObject); 
				return; 
			case RpglePackage.DCLF:
				sequence_Dclf(context, (Dclf) semanticObject); 
				return; 
			case RpglePackage.DCLPROC:
				sequence_Dclproc(context, (Dclproc) semanticObject); 
				return; 
			case RpglePackage.DCLS:
				sequence_Dcls(context, (Dcls) semanticObject); 
				return; 
			case RpglePackage.DIRECTIVE:
				sequence_Directive(context, (Directive) semanticObject); 
				return; 
			case RpglePackage.DO:
				sequence_Do(context, (Do) semanticObject); 
				return; 
			case RpglePackage.DOU:
				sequence_Dou(context, (Dou) semanticObject); 
				return; 
			case RpglePackage.DOW:
				sequence_Dow(context, (Dow) semanticObject); 
				return; 
			case RpglePackage.ELSE:
				sequence_Else(context, (Else) semanticObject); 
				return; 
			case RpglePackage.EOF:
				sequence_Eof(context, (Eof) semanticObject); 
				return; 
			case RpglePackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case RpglePackage.EXSR:
				sequence_Exsr(context, (Exsr) semanticObject); 
				return; 
			case RpglePackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case RpglePackage.LANGUAGE:
				sequence_Language(context, (Language) semanticObject); 
				return; 
			case RpglePackage.OPEN:
				sequence_Open(context, (Open) semanticObject); 
				return; 
			case RpglePackage.OPT:
				sequence_Opt(context, (Opt) semanticObject); 
				return; 
			case RpglePackage.OPTIONS:
				sequence_Options(context, (Options) semanticObject); 
				return; 
			case RpglePackage.OR:
				sequence_OrExpr(context, (Or) semanticObject); 
				return; 
			case RpglePackage.OTHER:
				sequence_Other(context, (Other) semanticObject); 
				return; 
			case RpglePackage.PARM1:
				if (rule == grammarAccess.getParm1Rule()
						|| rule == grammarAccess.getParm2Rule()) {
					sequence_Parm1(context, (Parm1) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getParmlistRule()) {
					sequence_Parm1_Parmlist(context, (Parm1) semanticObject); 
					return; 
				}
				else break;
			case RpglePackage.READ:
				sequence_Read(context, (Read) semanticObject); 
				return; 
			case RpglePackage.READE:
				sequence_Reade(context, (Reade) semanticObject); 
				return; 
			case RpglePackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case RpglePackage.RNF:
				sequence_Rnf(context, (Rnf) semanticObject); 
				return; 
			case RpglePackage.SELECTBLOCK:
				sequence_Selectblock(context, (Selectblock) semanticObject); 
				return; 
			case RpglePackage.SETGT:
				sequence_Setgt(context, (Setgt) semanticObject); 
				return; 
			case RpglePackage.SETLL:
				sequence_Setll(context, (Setll) semanticObject); 
				return; 
			case RpglePackage.SUBRUTINE:
				sequence_Subrutine(context, (Subrutine) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BoolExpr returns And
	 *     OrExpr returns And
	 *     OrExpr.Or_1_0 returns And
	 *     AndExpr returns And
	 *     AndExpr.And_1_0 returns And
	 *     PrimaryExpr returns And
	 *
	 * Constraint:
	 *     (left=AndExpr_And_1_0 right=PrimaryExpr)
	 */
	protected void sequence_AndExpr(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExprAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExprAccess().getRightPrimaryExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Assignment
	 *     Stmt returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (variable=[Dcls|ID] expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.ASSIGNMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.ASSIGNMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVariableDclsIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RpglePackage.Literals.ASSIGNMENT__VARIABLE, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     boolexprs+=BoolExpr*
	 */
	protected void sequence_Boolean(ISerializationContext context, org.sitemule.rpglanguage.rpgle.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Elseif returns Boolean
	 *
	 * Constraint:
	 *     (boolexprs+=BoolExpr* ifcode+=Code*)
	 */
	protected void sequence_Boolean_Elseif(ISerializationContext context, org.sitemule.rpglanguage.rpgle.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     If returns Boolean
	 *
	 * Constraint:
	 *     (boolexprs+=BoolExpr* ifcode+=Code*)
	 */
	protected void sequence_Boolean_If(ISerializationContext context, org.sitemule.rpglanguage.rpgle.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Boolean
	 *     Stmt returns Boolean
	 *     Ifblock returns Boolean
	 *
	 * Constraint:
	 *     (boolexprs+=BoolExpr* ifcode+=Code* ifcode+=Elseif* ifcode+=Else?)
	 */
	protected void sequence_Boolean_If_Ifblock(ISerializationContext context, org.sitemule.rpglanguage.rpgle.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     When returns Boolean
	 *
	 * Constraint:
	 *     (boolexprs+=BoolExpr* whencode+=Code*)
	 */
	protected void sequence_Boolean_When(ISerializationContext context, org.sitemule.rpglanguage.rpgle.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Chain
	 *     Chain returns Chain
	 *     Code returns Chain
	 *     Stmt returns Chain
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Chain(ISerializationContext context, Chain semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChainAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Close
	 *     Close returns Close
	 *     Code returns Close
	 *     Stmt returns Close
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Close(ISerializationContext context, Close semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCloseAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Compare2 returns CompareRight
	 *     CompareRight returns CompareRight
	 *
	 * Constraint:
	 *     ((spec=Special | intval2=INT | strval2=STRING | var2=[Dcls|ID] | bif2=Bif) cmp=Compare2?)
	 */
	protected void sequence_CompareRight(ISerializationContext context, CompareRight semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoolExpr returns Compare
	 *     OrExpr returns Compare
	 *     OrExpr.Or_1_0 returns Compare
	 *     AndExpr returns Compare
	 *     AndExpr.And_1_0 returns Compare
	 *     PrimaryExpr returns Compare
	 *     Compare returns Compare
	 *
	 * Constraint:
	 *     ((spec=Special | intval2=INT | strval2=STRING | var2=[Dcls|ID] | bif2=Bif) cmp=Compare2?)
	 */
	protected void sequence_Compare(ISerializationContext context, Compare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Ctrlopt
	 *     Ctrlopt returns Ctrlopt
	 *
	 * Constraint:
	 *     opt+=Opt+
	 */
	protected void sequence_Ctrlopt(ISerializationContext context, Ctrlopt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Datatype returns Datatype
	 *
	 * Constraint:
	 *     len=Len
	 */
	protected void sequence_Datatype(ISerializationContext context, Datatype semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.DATATYPE__LEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.DATATYPE__LEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatatypeAccess().getLenLenParserRuleCall_1_0(), semanticObject.getLen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Dclf
	 *     Declare returns Dclf
	 *     Dclf returns Dclf
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Dclf(ISerializationContext context, Dclf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.DECLARE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.DECLARE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDclfAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Dclproc
	 *     Declare returns Dclproc
	 *     Dclproc returns Dclproc
	 *
	 * Constraint:
	 *     (name=ID declare+=Declare* code+=Code*)
	 */
	protected void sequence_Dclproc(ISerializationContext context, Dclproc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Dcls
	 *     Declare returns Dcls
	 *     Dcls returns Dcls
	 *
	 * Constraint:
	 *     (name=ID datatype=Datatype options=Options?)
	 */
	protected void sequence_Dcls(ISerializationContext context, Dcls semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Directive
	 *     Directive returns Directive
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Directive(ISerializationContext context, Directive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.DIRECTIVE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.DIRECTIVE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDirectiveAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Do
	 *     Stmt returns Do
	 *     Do returns Do
	 *
	 * Constraint:
	 *     code+=Code+
	 */
	protected void sequence_Do(ISerializationContext context, Do semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Dou
	 *     Stmt returns Dou
	 *     Dou returns Dou
	 *
	 * Constraint:
	 *     (dou=Boolean code+=Code*)
	 */
	protected void sequence_Dou(ISerializationContext context, Dou semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Dow
	 *     Stmt returns Dow
	 *     Dow returns Dow
	 *
	 * Constraint:
	 *     (dow=Boolean code+=Code*)
	 */
	protected void sequence_Dow(ISerializationContext context, Dow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Else returns Else
	 *
	 * Constraint:
	 *     ifcode+=Code*
	 */
	protected void sequence_Else(ISerializationContext context, Else semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Eof
	 *     Eof returns Eof
	 *     Code returns Eof
	 *     Stmt returns Eof
	 *     Expression returns Eof
	 *     Bif returns Eof
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Eof(ISerializationContext context, Eof semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEofAccess().getNameDclfIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (intval=INT | strval=STRING | var=[Dcls|ID] | (procval=[Dclproc|ID] parmlist+=Parmlist?))
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Exsr
	 *     Exsr returns Exsr
	 *     Stmt returns Exsr
	 *
	 * Constraint:
	 *     name=[Subrutine|ID]
	 */
	protected void sequence_Exsr(ISerializationContext context, Exsr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.EXSR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.EXSR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExsrAccess().getNameSubrutineIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.EXSR__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns For
	 *     Stmt returns For
	 *     For returns For
	 *
	 * Constraint:
	 *     (var=[Dcls|ID] from=Expression to=Expression code+=Code*)
	 */
	protected void sequence_For(ISerializationContext context, For semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Language returns Language
	 *
	 * Constraint:
	 *     elements+=Components+
	 */
	protected void sequence_Language(ISerializationContext context, Language semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Open
	 *     Open returns Open
	 *     Code returns Open
	 *     Stmt returns Open
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Open(ISerializationContext context, Open semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOpenAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Opt returns Opt
	 *
	 * Constraint:
	 *     (name=ID value=STRING?)
	 */
	protected void sequence_Opt(ISerializationContext context, Opt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Options returns Options
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_Options(ISerializationContext context, Options semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.OPTIONS__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.OPTIONS__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionsAccess().getValSTRINGTerminalRuleCall_2_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoolExpr returns Or
	 *     OrExpr returns Or
	 *     OrExpr.Or_1_0 returns Or
	 *     AndExpr returns Or
	 *     AndExpr.And_1_0 returns Or
	 *     PrimaryExpr returns Or
	 *
	 * Constraint:
	 *     (left=OrExpr_Or_1_0 right=AndExpr)
	 */
	protected void sequence_OrExpr(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExprAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExprAccess().getRightAndExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Other returns Other
	 *
	 * Constraint:
	 *     othercode+=Code*
	 */
	protected void sequence_Other(ISerializationContext context, Other semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parm1 returns Parm1
	 *     Parm2 returns Parm1
	 *
	 * Constraint:
	 *     parm=Expression
	 */
	protected void sequence_Parm1(ISerializationContext context, Parm1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.PARM1__PARM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.PARM1__PARM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParm1Access().getParmExpressionParserRuleCall_0(), semanticObject.getParm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parmlist returns Parm1
	 *
	 * Constraint:
	 *     (parm=Expression parms+=Parm2*)
	 */
	protected void sequence_Parm1_Parmlist(ISerializationContext context, Parm1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Read
	 *     Read returns Read
	 *     Code returns Read
	 *     Stmt returns Read
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Read(ISerializationContext context, Read semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Reade
	 *     Reade returns Reade
	 *     Code returns Reade
	 *     Stmt returns Reade
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Reade(ISerializationContext context, Reade semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadeAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Return
	 *     Stmt returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expression+=Expression?
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Rnf
	 *     Rnf returns Rnf
	 *     Code returns Rnf
	 *     Stmt returns Rnf
	 *     Expression returns Rnf
	 *     Bif returns Rnf
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Rnf(ISerializationContext context, Rnf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRnfAccess().getNameDclfIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Selectblock
	 *     Stmt returns Selectblock
	 *     Selectblock returns Selectblock
	 *
	 * Constraint:
	 *     (when=When* other=Other?)
	 */
	protected void sequence_Selectblock(ISerializationContext context, Selectblock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Setgt
	 *     Setgt returns Setgt
	 *     Code returns Setgt
	 *     Stmt returns Setgt
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Setgt(ISerializationContext context, Setgt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetgtAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fileio returns Setll
	 *     Setll returns Setll
	 *     Code returns Setll
	 *     Stmt returns Setll
	 *
	 * Constraint:
	 *     name=[Dclf|ID]
	 */
	protected void sequence_Setll(ISerializationContext context, Setll semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RpglePackage.Literals.FILEIO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RpglePackage.Literals.FILEIO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetllAccess().getNameDclfIDTerminalRuleCall_1_0_1(), semanticObject.eGet(RpglePackage.Literals.FILEIO__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Code returns Subrutine
	 *     Subrutine returns Subrutine
	 *
	 * Constraint:
	 *     (name=ID subrcode+=Code*)
	 */
	protected void sequence_Subrutine(ISerializationContext context, Subrutine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
